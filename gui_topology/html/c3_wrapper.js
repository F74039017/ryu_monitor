/*
 * c3_wrapper is a data wrapper, which defines an interface between c3.js and dpi_oper.js
 * These API offer a convenient way to update the chart with data from dpi_oper.js
 * C3 chart must be generated by c3.js library, and update events can be registered with this API.
 *
 * Notice:
 *  Only allow to use data.row() format currently.
 *  One chart is only allowed to connect to one kind of data
 *
 * TODO:
 *  
 *  connectData(chart, id, filter, size=10):
 *      chart: chart object created by c3.js
 *      id: ipv4 or dpid
 *      type: 'dpi' or 'port'
 *      size: size of history
 *
 *  disconnectData(chart):
 *      disconnect the chart data flow
 *
 *  setHistorySize(size):
 *      set the number of nodes shown in the chart.
 *      if the size is greater than that of present, append new data.
 *      else if size is less than that of present, only keep the latest number of data.
 *
 *  setType(type):
 *      'dpi' or 'port'.
 *      clear history data and transfer type between dpi and port.
 *
 *  clearData(chart):
 *      clear history data
 *      
 * */

function c3_wrapper(dpi_oper) {
    this.manager; 
    this.idCnt; // use increment number as id. According to ES5, id can up to 2^53-1.
    this.dpi_oper;
    this.tryPeriod; // if dpi_oper not ready, try after 100ms

    /* constructor */

    this.manager = [];  // [connections..]
    this.idCnt = 0;
    this.dpi_oper = null;
    this.tryPeriod = 100; // try to connect dpi_oper every 100ms at most 10 times
    this.tryLimit = 10;

    this.dpi_oper = dpi_oper; // init dpi_oper
}

/**********************************
 *  Helper function
 **********************************/

c3_wrapper.prototype.genId = function() {
    return this.idCnt++;
}

/*
 * connFilter define which data should be collected from dpi_oper
 * if dpi filter is null, then it will collect all dpi data.
 * */
c3_wrapper.prototype.setConnFilter = function(filter, conn) {
    if(!filter.hasOwnProperty('dpi'))
        throw "lack of dpi field";
    if(!filter.hasOwnProperty('port'))
        throw "lack of port field";

    /* set port filter */
    if(filter['port'] == null) {
        conn['connFilter']['port'] = ['rx_pkt', 'rx_byte', 'tx_pkt', 'tx_byte', 'tot_pkt', 'tot_byte'];
    }
    else if(typeof filter['port'] === 'string') {
        // one param
		if(!this.isPortInfo(filter['port']))
			throw "wrong port field name: "+filter['port'];
        conn['connFilter']['port'].push(filter['port']);
    }
    else if(Object.prototype.toString.call(filter['port']) === '[object Array]') {
		for(var x in filter['port']) {
			if(!this.isPortInfo(filter['port'][x]))
				throw "wrong port field name: "+filter['port'][x];
		}
        conn['connFilter']['port'] = filter['port'].slice();
    }
    else
        throw "wrong port type";

    /* set dpi filter */
    if(filter['dpi'] == null) {
        conn['connFilter']['dpi'] = null; // this will collect all protocol info
    }
    else if(typeof filter['dpi'] === 'string') {
        // one param
        conn['connFilter']['dpi'].push(filter['dpi']);
    }
    else if(Object.prototype.toString.call(filter['dpi']) === '[object Array]') {
        conn['connFilter']['dpi'] = filter['dpi'].slice();
    }
    else
        throw "wrong dpi type";
}

/*
 * showFilter define which data should be shown in the chart
 * showFilter must be subset of connFilter
 * if dpi filter is null, then it will show protocols info. as many as possible
 * */
c3_wrapper.prototype.setShowFilter = function(showFilter, conn) {
    if(!showFilter.hasOwnProperty('dpi'))
        throw "lack of dpi field";
    if(!showFilter.hasOwnProperty('port'))
        throw "lack of port field";

    var dpi_list = showFilter['dpi'];
    var port_list = showFilter['port'];

    try {

        /* set port filter */
        if(port_list == null) {
            conn['showFilter']['port'] = conn['connFilter']['port'].slice();
        }
        else if(typeof port_list === 'string') {
            this.tryAppend(port_list, conn['connFilter']['port'], conn['showFilter']['port']);
        }
        else if(Object.prototype.toString.call(port_list) === '[object Array]') {
            for(var x in port_list) {
                this.tryAppend(port_list[x], conn['connFilter']['port'], conn['showFilter']['port']);
            }
        }
        else
            throw "wrong port type";

        /* set dpi filter */
        if(dpi_list == null) {
            if(conn['connFilter']['dpi'] == null)
                conn['showFilter']['dpi'] = null;
            else
                conn['showFilter']['dpi'] = conn['connFilter']['dpi'].slice();
        }
        else if(typeof dpi_list === 'string') {
            this.tryAppend(dpi_list, conn['connFilter']['dpi'], conn['showFilter']['dpi']);
        }
        else if(Object.prototype.toString.call(dpi_list) === '[object Array]') {
            for(var x in dpi_list) {
                this.tryAppend(dpi_list[x], conn['connFilter']['dpi'], conn['showFilter']['dpi']);
            }
        }
        else
            throw "wrong dpi type";
    }
    catch(err) {
        console.log(err);
        throw err; // rethrow
    }


}

/* if element in carr, then push to iarr */
c3_wrapper.prototype.tryAppend = function(element, carr, iarr) {
    if(inArray(element, carr))
        iarr.push(element);
    else
        throw "showFilter must be subset of connFilter";
}

c3_wrapper.prototype.inArray = function(str, arr) {
    for(var x in arr) {
        var tmp = arr[x];
        if(tmp == str)
            return true;
    }
    return false;
}

c3_wrapper.prototype.isPortInfo= function(str) {
    if(str=='rx_pkt' || str=='rx_byte' || str=='tx_pkt' || str=='tx_byte' || str=='tot_pkt' || str=='tot_byte')
        return true;
    else
        return false;
}

/*
 * connection:
 * {   'ref': obj, 
 *      'ts': []
 *      'tsCnt': int // ts counter, set chart => data: {x: 'ts'}
 *      'size': size, // For gauge, we can set it to 1 to keep only current value.
 *      'connFilter': {'dpi': [string ...], 'port': [string ...]}
 *      'showFilter': {'dpi': [string ...], 'port': [string ...]}
 *      'data': {'dpi': {protoName: []}, 'port': {rx_pkt: []}}
 *      'cb_name': string // Generate by c3_wrapper idCnt
 *      'id': int // ipv4 or dpid
 * }
 *  
 * */
c3_wrapper.prototype.genConnection = function(chart, id, connFilter, showFilter, size) {
    var _id = this.genId();

    if(chart==null)
        throw "chart is null";

    if(size<=0)
        throw "size can not <= 0";

    var conn =  {ref: chart, ts: ['ts'], tsCnt: 0, size: size, connFilter: {'dpi': [], 'port': []}, showFilter: {'dpi': [], 'port': []}, data: {'dpi': {}, 'port': {}}, cb_name: _id, id: id};
    this.setConnFilter(connFilter, conn);
    this.setShowFilter(showFilter, conn);

    return conn;
}

/* check dpi_oper is ready */
c3_wrapper.prototype.isReady = function() {
    if(this.dpi_oper && this.dpi_oper.isReady()) {
        return true;
    }
    return false;
}

c3_wrapper.prototype.deepCloneObj = function(obj) {
    return JSON.parse(JSON.stringify(obj));
}

/* 
 * db => data array
 * protoName
 * value => [byte, pkt]
 * */
c3_wrapper.prototype.appendDPIData = function(db, protoName, value) {
    var pkt_field = protoName+"_pkt";
    var byte_field = protoName+"_byte";

    if(!db.hasOwnProperty(byte_field)) {
        db[byte_field] = [byte_field, value[0]];
    }  
    else {
        db[byte_field].push(value[0]);
    }

    if(!db.hasOwnProperty(pkt_field)) {
        db[pkt_field] = [pkt_field, value[1]];
    }  
    else {
        db[pkt_field].push(value[1]);
    }
}

c3_wrapper.prototype.appendPortData = function(db, fieldName, value) {
    if(!this.isPortInfo(fieldName))
        throw "error port field";
    if(!db.hasOwnProperty(fieldName)) {
        db[fieldName] = [fieldName, value];
    }  
    else {
        db[fieldName].push(value);
    }
}


/**********************************
 *  API
 **********************************/

/*
 * XXX: not allow duplicated field in filter
 * */
c3_wrapper.prototype.connectData = function(chart, id, connFilter={dpi: null, port: null}, showFilter={dpi: null, port: null}, size=10, failTime=0) {

	if(failTime==this.tryLimit) {
		throw "can not connect dpi_oper";
	}

    /* wait for ready */
	if(!this.isReady()) {
		var _this = this;
		setTimeout(function(){_this.connectData(chart, id, connFilter, showFilter, size, failTime+1)}, this.tryPeriod);
		return;
	}

    var conn = this.genConnection(chart, id, connFilter, showFilter, size);

    /* register dpi_oper callback */
    try {
        _this = this; 

        /* Register dpi data */
        this.dpi_oper.regCallBack('dpi', conn.cb_name, id, function(dpi_data){
            
            //console.log(data);
            //console.log(this);
            //console.log(conn);
            
            var db = conn.data['dpi'];
            console.log(dpi_data);
            for(var x in dpi_data) {
                if(conn.connFilter['dpi']==null || this.inArray(dpi_data[x]['protoName'], conn.connFilter['dpi'])) { // check connFilter
                    _this.appendDPIData(db, dpi_data[x]['protoName'], [dpi_data[x]['bytes'], dpi_data[x]['packets']]);
                }
            }

            console.log(db);
            //chart.load({
                //x: 'ts',
                //columns: [
                    //data.Google,
                    //data.Yahoo,
                    //data.Facebook,
                    //data.ts
                //]	
            //});

        }, this)

        /* Register port data */
        this.dpi_oper.regCallBack('port', conn.cb_name, id, function(port_data){
            // this is chart, _this is c3_wrapper
            
            //console.log(data);
            var db = conn.data['port'];
            console.log(port_data);
            for(var fieldName in port_data) {
                if(this.inArray(fieldName, conn.connFilter['port'])) { // check connFilter
                    _this.appendPortData(db, fieldName, port_data[fieldName]);
                }
            }

            //console.log(JSON.stringify(db));

        }, this)

    }
    catch(err) {
        console.log("connectData error: "+err);
        return;
    }

    return conn;
}

c3_wrapper.prototype.disconnectData = function(chart) {

}

c3_wrapper.prototype.setHistorySize = function(size) {

}

c3_wrapper.prototype.setType = function(type) {

}

c3_wrapper.prototype.clearData = function(chart) {

}

