/*
 * c3_wrapper is a data wrapper, which defines an interface between c3.js and dpi_oper.js
 * These API offer a convenient way to connect data in c3.js columns form and update chart periodically.
 * C3 chart must be generated by c3.js library, and update events can be registered with this API.
 *
 * Notice:
 *  Only allow to use data.columns() format currently.
 *
 *  connectData(chart, id, connFilter={dpi: null, port: null}, showFilter={dpi: null, port: null, bp_flag: null, port_no: null}, size=10)
 *      chart: chart object created by c3.js
 *      id: ipv4 or dpid
 *      connFilter: only connect these data
 *      showFilter: only show these data
 *      size: size of history
 *      This API will register event to dpi_oper and save data as c3.js columns style.
 *
 *  XXX: data are updated per second currently..
 *  startShowLine(chart, type, rank=null):
 *      type => 'dpi' or 'port'
 *      show data on chart per second
 *  stopShow(chart):
 *      stop load new data to chart
 *
 *  setHistorySize(size):
 *      set the number of nodes shown in the chart.
 *      if the size is greater than that of present, append new data.
 *      else if size is less than that of present, only keep the latest number of data.
 *
 *  XXX: after reset showFilter, remember "unload() the chart"
 *  XXX: unstable...
 *  setShowFilter(showFilter, conn):
 *      reset showFilter in the connection.
 *
 *  destroy(chart):
 *      clear all events and remove connection from manager
 *
 *  chart2conn(chart):
 *      convert chart to connection element
 *  removeConnByChart(chart):
 *      similar to chart2conn, but remove conn from manager before return connection
 *
 *  clearData(chart):
 *      clear all records
 *
 *  XXX: BUG in tot_xxx field... 
 *  Do not use it.
 *
 *  XXX: host port info. => info. contain in port 1.
 *
 * */

function c3_wrapper(dpi_oper) {
    this.manager;
    this.idCnt; // use increment number as id. According to ES5, id can up to 2^53-1.
    this.dpi_oper;
    this.tryPeriod; // if dpi_oper not ready, try after 100ms
    this.destroy_delay;

    /* constructor */

    this.manager = []; // [connections..]
    this.idCnt = 0;
    this.dpi_oper = null;
    this.tryPeriod = 100; // try to connect dpi_oper every 100ms at most 10 times
    this.tryLimit = 10;

    this.dpi_oper = dpi_oper; // init dpi_oper
}

/**********************************
 *  Helper function
 **********************************/

c3_wrapper.prototype.destroy_delay = 0;

/* process obj {name: 'A', value: int} */
c3_wrapper.prototype.protoCMP = function(a, b) {
    if (a.value == b.value) {
        return a.name.localeCompare(b.name);
    }
    return a.value - b.value;
}

c3_wrapper.prototype.updateDPIrank = function(conn) {
    var db = conn.data['dpi'];
    var dpi_rank = conn['dpi_rank'];
    var proto_byte = [],
        proto_pkt = [];
    for (var x in db) {
        var field = x; // protoName_byte or protoName_pkt
        var last_char = field.charAt(field.length - 1);
        var protoName;
        var len = db[x].length;
        if (last_char == 'e') {
            var protoName = field.substring(0, field.length - 5);
            var avg_byte_ref = dpi_rank['avg_byte'];
            if (!avg_byte_ref.hasOwnProperty(protoName)) {
                avg_byte_ref[protoName] = 0.125 * db[x][len - 1] + 0.875 * 0;
            } else {
                avg_byte_ref[protoName] = 0.125 * db[x][len - 1] + 0.875 * avg_byte_ref[protoName];
            }
            proto_byte.push({ name: protoName, value: avg_byte_ref[protoName] });
        } else if (last_char == 't') {
            var protoName = field.substring(0, field.length - 4);
            var avg_pkt_ref = dpi_rank['avg_pkt'];
            if (!avg_pkt_ref.hasOwnProperty(protoName)) {
                avg_pkt_ref[protoName] = 0.125 * db[x][len - 1] + 0.875 * 0;
            } else {
                avg_pkt_ref[protoName] = 0.125 * db[x][len - 1] + 0.875 * avg_pkt_ref[protoName];
            }
            proto_pkt.push({ name: protoName, value: avg_byte_ref[protoName] });
        } else {
            throw "error dpi field: " + field;
        }
    }

    dpi_rank['byte'] = proto_byte.sort(c3_wrapper.prototype.protoCMP).reverse();
    dpi_rank['pkt'] = proto_pkt.sort(c3_wrapper.prototype.protoCMP).reverse();
    //console.log(JSON.stringify(dpi_rank['byte']));
}

c3_wrapper.prototype.genId = function() {
    return this.idCnt++;
}

/*
 * connFilter define which data should be collected from dpi_oper
 * if dpi filter is null, then it will collect all dpi data.
 * */
c3_wrapper.prototype.setConnFilter = function(filter, conn) {
    if (!filter.hasOwnProperty('dpi'))
        throw "lack of dpi field";
    if (!filter.hasOwnProperty('port'))
        throw "lack of port field";

    /* set port filter */
    if (filter['port'] == null) {
        //conn['connFilter']['port'] = ['rx_pkt', 'rx_byte', 'tx_pkt', 'tx_byte', 'tot_pkt', 'tot_byte'];

        // Some bugs in tot_xxx
        conn['connFilter']['port'] = ['rx_pkt', 'rx_byte', 'tx_pkt', 'tx_byte'];
    } else if (typeof filter['port'] === 'string') {
        // one param
        if (!this.isPortInfo(filter['port']))
            throw "wrong port field name: " + filter['port'];
        conn['connFilter']['port'].push(filter['port']);
    } else if (Object.prototype.toString.call(filter['port']) === '[object Array]') {
        for (var x in filter['port']) {
            if (!this.isPortInfo(filter['port'][x]))
                throw "wrong port field name: " + filter['port'][x];
        }
        conn['connFilter']['port'] = filter['port'].slice();
    } else
        throw "wrong port type";

    /* set dpi filter */
    if (filter['dpi'] == null) {
        conn['connFilter']['dpi'] = null; // this will collect all protocol info
    } else if (typeof filter['dpi'] === 'string') {
        // one param
        conn['connFilter']['dpi'].push(filter['dpi']);
    } else if (Object.prototype.toString.call(filter['dpi']) === '[object Array]') {
        conn['connFilter']['dpi'] = filter['dpi'].slice();
    } else
        throw "wrong dpi type";
}

/*
 * showFilter define which data should be shown in the chart
 * showFilter must be subset of connFilter
 * if dpi filter is null, then it will show protocols info. as many as possible
 * */
c3_wrapper.prototype.setShowFilter = function(showFilter, conn) {
    if (!showFilter.hasOwnProperty('dpi'))
        showFilter['dpi'] = null;
    if (!showFilter.hasOwnProperty('port'))
        showFilter['port'] = null;

    /* reset showFilter in connection */
    conn.showFilter = { 'dpi': [], 'port': [] };


    var dpi_list = showFilter['dpi'];
    var port_list = showFilter['port'];

    try {

        /* set port filter */
        if (port_list == null) {
            conn['showFilter']['port'] = conn['connFilter']['port'].slice();
        } else if (typeof port_list === 'string') {
            this.tryAppend(port_list, conn['connFilter']['port'], conn['showFilter']['port']);
        } else if (Object.prototype.toString.call(port_list) === '[object Array]') {
            for (var x in port_list) {
                this.tryAppend(port_list[x], conn['connFilter']['port'], conn['showFilter']['port']);
            }
        } else
            throw "wrong port type";

        if (!showFilter.hasOwnProperty('port_no')) {
            showFilter['port_no'] = null; // null port_no will show all ports
        } else if (showFilter['port_no'] != null) {

            if (typeof showFilter['port_no'] == 'number') { // only one port
                conn['showFilter']['port_no'] = [showFilter['port_no']];
            } else { // port array
                /* int validate */
                for (var x in showFilter['port_no']) {
                    var port = showFilter['port_no'][x];
                    if (!Number.isInteger(port))
                        throw "showFilter: port_no not integer";
                }
                conn['showFilter']['port_no'] = showFilter['port_no'].slice();
            }
        }

        /* set dpi filter */
        if (dpi_list == null) {
            if (conn['connFilter']['dpi'] == null)
                conn['showFilter']['dpi'] = null;
            else
                conn['showFilter']['dpi'] = conn['connFilter']['dpi'].slice();
        } else if (typeof dpi_list === 'string') {
            this.tryAppend(dpi_list, conn['connFilter']['dpi'], conn['showFilter']['dpi']);
        } else if (Object.prototype.toString.call(dpi_list) === '[object Array]') {
            for (var x in dpi_list) {
                this.tryAppend(dpi_list[x], conn['connFilter']['dpi'], conn['showFilter']['dpi']);
            }
        } else
            throw "wrong dpi type";

        if (!showFilter.hasOwnProperty('bp_flag') || showFilter['bp_flag'] == null) {
            conn['showFilter']['bp_flag'] = 3; // show both port and byte
        } else if (Number.isInteger(showFilter['bp_flag'])) {
            conn['showFilter']['bp_flag'] = showFilter['bp_flag'];
        } else
            throw " bp_flag not integer in showFilter";
    } catch (err) {
        console.log(err);
        throw err; // rethrow
    }
}

/* if element in carr, then push to iarr */
c3_wrapper.prototype.tryAppend = function(element, carr, iarr) {
    if (this.inArray(element, carr))
        iarr.push(element);
    else
        throw "showFilter must be subset of connFilter";
}

c3_wrapper.prototype.inArray = function(str, arr) {
    for (var x in arr) {
        var tmp = arr[x];
        if (tmp == str)
            return true;
    }
    return false;
}

c3_wrapper.prototype.isPortInfo = function(str) {
    if (str == 'rx_pkt' || str == 'rx_byte' || str == 'tx_pkt' || str == 'tx_byte' || str == 'tot_pkt' || str == 'tot_byte')
        return true;
    else
        return false;
}

/*
 * connection:
 * {   'ref': obj, 
 *      'dpi_ts': []
 *      'dpi_sts': int // ts counter, set chart => data: {x: 'dpi_ts'}
 *      'port_ts': []
 *      'port_sts': int 
 *      'size': size, // For gauge, we can set it to 1 to keep only current value.
 *      'connFilter': {'dpi': [string ...], 'port': [string ...]}
 *      'showFilter': {'dpi': [string ...], 'port': [string ...], 'port_no'}
 *      'data': {'dpi': {protoName: []}, 'port': { port_no: {rx_pkt: [], ...}, tot_byte: int, tot_pkt: int}}
 *      'port_data_ready': false // port is cumulative data. Therefore, we need to wait for second data and calulate the first delta value
 *      'cb_name': string // Generate by c3_wrapper idCnt
 *      'id': int // ipv4 or dpid
 *      'intervalId': setInterval id
 *      'dpi_rank': {byte: [], pkt: [], avg_byte: {}, avg_pkt: {}} // avg is the average value
 * }
 *  
 * */
c3_wrapper.prototype.genConnection = function(chart, id, connFilter, showFilter, size) {
    var _id = this.genId();

    if (chart == null)
        throw "chart is null";

    if (size <= 0)
        throw "size can not <= 0";

    var conn = { ref: chart, dpi_ts: ['ts'], dpi_sts: null, port_ts: ['ts'], port_sts: null, size: size, connFilter: { 'dpi': [], 'port': [] }, showFilter: { 'dpi': [], 'port': [] }, data: { 'dpi': {}, 'port': {} }, cb_name: _id, id: id, port_data_ready: false, intervalId: null, dpi_rank: { byte: [], pkt: [], avg_byte: {}, avg_pkt: {} } };
    this.setConnFilter(connFilter, conn);
    this.setShowFilter(showFilter, conn);

    return conn;
}

/* check dpi_oper is ready */
c3_wrapper.prototype.isReady = function() {
    if (this.dpi_oper && this.dpi_oper.isReady()) {
        return true;
    }
    return false;
}

c3_wrapper.prototype.deepCloneObj = function(obj) {
    return JSON.parse(JSON.stringify(obj));
}

/* 
 * db => data array
 * protoName
 * value => [byte, pkt]
 * head_padding => if not exist field, padding head 0
 * */
c3_wrapper.prototype.appendDPIData = function(db, protoName, value, head_padding = 0) {
    var pkt_field = protoName + "_pkt";
    var byte_field = protoName + "_byte";

    /* padding head 0 */
    if (!db.hasOwnProperty(byte_field)) {
        db[byte_field] = [];
        if (head_padding != 0) {
            db[byte_field] = Array(head_padding + 1).fill(0);
        }
        // XXX: both byte and pkt data's tag are protoName!!
        // Do not show them at the same time...
        db[byte_field][0] = protoName;
    }
    db[byte_field].push(value[0]);

    if (!db.hasOwnProperty(pkt_field)) {
        db[pkt_field] = [];
        if (head_padding != 0) {
            db[pkt_field] = Array(head_padding + 1).fill(0);
        }
        db[pkt_field][0] = protoName;
    }
    db[pkt_field].push(value[1]);
}

/* process one kind of field. e.g rx_pkt */
c3_wrapper.prototype.appendPortData = function(conn, fieldName, port_data, size, dpi) {
    var db = conn.data['port'];
    if (!this.isPortInfo(fieldName))
        throw "error port field";

    if (fieldName == 'tot_pkt' || fieldName == 'tot_byte') {
        if (!db.hasOwnProperty(fieldName)) {
            db[fieldName] = [fieldName, port_data[fieldName]];
        } else {
            var last = db[fieldName].pop();
            db[fieldName].push(port_data[fieldName] - last);
            db[fieldName].push(port_data[fieldName]);
            this.rmOldData(db[fieldName], size + 1); // +1 => last record
        }
    } else {
        for (var x in port_data) {
            if (!isNaN(parseInt(x))) {
                var port_no = x;
                var dst_id = dpi.idPort2id(conn.id, port_no);
                if (dst_id == null)
                    continue;
                if (!db.hasOwnProperty(port_no)) {
                    db[port_no] = {};
                }

                if (!db[port_no].hasOwnProperty(fieldName)) {
                    //db[port_no][fieldName] = [port_no+"_"+fieldName, port_data[port_no][fieldName]];
                    db[port_no][fieldName] = [dst_id[1].toString() + "_" + fieldName, port_data[port_no][fieldName]];
                } else {
                    var last = db[port_no][fieldName].pop();
                    db[port_no][fieldName].push(port_data[port_no][fieldName] - last);
                    db[port_no][fieldName].push(port_data[port_no][fieldName]);
                    this.rmOldData(db[port_no][fieldName], size + 1); // +1 => last record
                }
            }
        }
    }

}

c3_wrapper.prototype.rmOldData = function(arr, size) {
    if (arr.length > size + 1) {
        var delta = arr.length - size - 1;
        arr.splice(1, delta);
    }
}

/* 
 * unload old legend and update new data
 * if chart.unload_flag is true, unload all, set the flag false and reload columns
 * */
c3_wrapper.prototype.checkUnload = function(chart, columns) {
    if (chart.hasOwnProperty('unload_flag') && chart.unload_flag) {
        chart.unload({
            done: function() {
                /* update c3 chart */
                chart.unload_flag = false;
                chart.loading = true;
                chart.load({
                    x: 'ts',
                    columns: columns,
                    done: function() {
                        setTimeout(function() { chart.loading = false; }, c3_wrapper.prototype.destroy_delay);
                    }
                });
            }
        });
        return false;
    }

    var unload_list = [];
    for (var x in chart.internal.legend[0][0].childNodes) { // all legends
        var name = chart.internal.legend[0][0].childNodes[x].__data__;
        var ok = false;
        if (typeof name == "undefined")
            continue;
        for (var i in columns) { // in columns
            if (name == columns[i][0]) {
                ok = true;
                break;
            }
        }
        if (!ok) {
            unload_list.push(name);
        }
    }
    if (unload_list.length != 0) {
        chart.unload({
            ids: unload_list,
            done: function() {
                /* update c3 chart */
                chart.loading = true;
                chart.load({
                    x: 'ts',
                    columns: columns,
                    done: function() {
                        setTimeout(function() { chart.loading = false; }, c3_wrapper.prototype.destroy_delay);
                    }
                });
            }
        });
        return false;
    }
    return true;
}


/**********************************
 *  API
 **********************************/

/*
 * XXX: not allow duplicated field in filter
 * bp_flag: 1=>byte, 2=>pkt
 * */
c3_wrapper.prototype.connectData = function(chart, id, connFilter = { dpi: null, port: null }, showFilter = { dpi: null, port: null, bp_flag: null, port_no: null }, size = 10, failTime = 0) {

    if (c3w.chart2conn(chart)) {
        console.log("already connected");
        return null;
    }

    if (failTime == this.tryLimit) {
        throw "can not connect dpi_oper";
    }

    /* wait for ready */
    if (!this.isReady()) {
        var _this = this;
        setTimeout(function() { _this.connectData(chart, id, connFilter, showFilter, size, failTime + 1) }, this.tryPeriod);
        return;
    }

    if (connFilter == null)
        connFilter = { dpi: null, port: null };
    if (showFilter == null)
        showFilter = { dpi: null, port: null, bp_flag: null, port_no: null };

    var conn = this.genConnection(chart, id, connFilter, showFilter, size);

    /* register dpi_oper callback */
    try {
        _this = this;

        /* Register dpi data */
        this.dpi_oper.regCallBack('dpi', conn.cb_name, id, function(dpi_data) {

            var db = conn.data['dpi'];
            //console.log(dpi_data);

            /* add ts */
            var diff_time = addTS('dpi', conn);

            /* add dpi data */
            for (var x in dpi_data) {
                if (conn.connFilter['dpi'] == null || this.inArray(dpi_data[x]['protoName'], conn.connFilter['dpi'])) { // check connFilter
                    var protoName = dpi_data[x]['protoName'];
                    // diff_time = null if not first data
                    _this.appendDPIData(db, protoName, [dpi_data[x]['bytes'], dpi_data[x]['packets']], Math.round(diff_time / 1000));
                }
            }

            /* 
             * padding tail 0 
             * Some protocols appear this sec, but not appear in next sec
             * */
            var len = conn['dpi_ts'].length;
            for (var x in db) {
                if (db[x].length < len) {
                    db[x].push(0);
                }

                /* check history len */
                this.rmOldData(db[x], conn.size);
            }
            this.rmOldData(conn['dpi_ts'], conn.size);

            /* update rank */
            this.updateDPIrank(conn);
        }, this)


        /* Register port data */
        this.dpi_oper.regCallBack('port', conn.cb_name, id, function(port_data) {

            /* add ts */
            if (conn.port_data_ready) {
                addTS('port', conn);
            }

            /* add port data */
            for (var x in conn.connFilter['port']) { // try to add all field in connFilter
                var fieldName = conn.connFilter['port'][x];
                _this.appendPortData(conn, fieldName, port_data, conn.size, this.dpi_oper); // port_data = {port_no: {} || tot_xxx: int}
            }
            this.rmOldData(conn['port_ts'], conn.size);

            //console.log(JSON.stringify(port_data));

            conn.port_data_ready = true; // only skip first data

        }, this)

    } catch (err) {
        console.log("connectData error: " + err);
        return;
    }

    /* return diff time */
    function addTS(type, conn) {
        if (type != 'port' && type != 'dpi') {
            throw "wrong type in addTS()";
        }

        var diff_time = null;
        if (conn[type + '_sts'] == null) {
            conn[type + '_sts'] = (new Date()).getTime();
            conn[type + '_ts'].push(0);
        } else {
            diff_time = (new Date()).getTime() - conn[type + '_sts'];
            conn[type + '_ts'].push(Math.round(diff_time / 1000));
        }

        return diff_time;
    }

    this.manager.push(conn);
    chart.unload_flag = false;

    return conn;
}

/*
 * clear dpi_oper callback and remove connection from manager
 * */
c3_wrapper.prototype.destroy = function(chart, callback = null, tryCnt = 0) {
    // delay and try
    //console.log(chart.loading);
    if (chart.hasOwnProperty('loading') && chart.loading) {
        var _this = this;
        if (tryCnt == 10) {
            throw "can't destroy chart, keep loading?";
        }
        setTimeout(function() { _this.destroy(chart, callback, tryCnt + 1) }, 100);
        return;
    }

    console.log("stop and destroy");
    this.stopShow(chart);
    var conn = this.removeConnByChart(chart); // if chart==null or can't be found, conn=null
    if (conn) {
        var dpi = this.dpi_oper;
        try {
            dpi.removeCallback('dpi', conn.cb_name);
            dpi.removeCallback('port', conn.cb_name);
        } catch (err) {
            console.log("Destroy error: " + err); // not rethrow
        }
        // XXX: c3 internal async bug.
        //chart.destroy();
    } else {
        // shareConn chart
        //chart.destroy();
    }

    if (callback) {
        callback();
    }
}

/* 
 * show data on chart 
 * data_type: dpi or port
 * rt_rank: 
 *      port => 0: both, 1: rx, 2: tx
 *      dpi => only show top rank
 * return: false => not start successfully
 * */
c3_wrapper.prototype.startShowLine = function(chart, data_type, rt_rank = null) {

    var conn = this.chart2conn(chart);
    if (chart.hasOwnProperty("intervalId")) {
        console.log("The chart is showed as proto pie");
        return false;
    }

    if (!conn) {
        console.log("can not found connection");
        return false;
    } else if (conn.intervalId) {
        console.log("already start show: " + conn.intervalId.toString());
        return false;
    } else if (rt_rank != null && !Number.isInteger(rt_rank)) {
        console.log("rt_rank isn't integer");
        return false;
    }

    chart.unload_flag = true; // force reunload all
    var _this = this;
    var setId;

    if (rt_rank == null) {
        if (data_type == 'port') {
            chart.rt_rank = 1; // default show byte port info.
        } else {
            chart.rt_rank = 3; // default show top 3 protocols
        }
    } else
        chart.rt_rank = rt_rank;

    chart.transform('line');
    if (data_type == 'port') {
        setId = setInterval(function() {
            var db = conn.data['port'];
            var rt_flag = chart.rt_rank;
            window.rt_stat = rt_flag;

            /* prepare columns */
            var columns = [];
            columns.push(conn['port_ts']);
            //for(var x in conn.showFilter['port']) {
            //var fieldName = conn.showFilter['port'][x];
            //if(fieldName.substring(0, 3)=='tot') { // tot_xxx
            //if(typeof db[fieldName] != 'undefined') {
            //columns.push(db[fieldName].slice(0, -1));
            //}
            //}
            //else {
            //for(var x in db) {
            //var port = parseInt(x);
            //// check show port_no
            //if(!isNaN(port) && (conn.showFilter['port_no']==null || _this.inArray(port, conn.showFilter['port_no']))) { 
            //if(typeof db[x][fieldName] != 'undefined') {
            //columns.push(db[x][fieldName].slice(0, -1));
            //}
            //}
            //}
            //}
            //}

            var flag = conn.showFilter['bp_flag'];
            window.bp_stat = flag;
            for (var x in conn.showFilter['port']) {
                var fieldName = conn.showFilter['port'][x];
                if ((rt_flag & 1) > 0 && fieldName.charAt(0) != 'r') // rx
                    continue;
                if ((rt_flag & 2) > 0 && fieldName.charAt(0) != 't') // tx
                    continue;

                if (fieldName.substring(0, 3) == 'tot') { // tot_xxx
                    continue; // not show tot_xxx because of bug
                } else {
                    for (var x in db) {
                        var port = parseInt(x);
                        // check show port_no
                        if (port == 4294967294) // exclude controller port
                            continue;

                        if (!isNaN(port) && (conn.showFilter['port_no'] == null || _this.inArray(port, conn.showFilter['port_no']))) {
                            if (typeof db[x][fieldName] != 'undefined') {
                                if ((fieldName == 'rx_byte' || fieldName == 'tx_byte') && (1 & flag) > 0) { // byte
                                    columns.push(db[x][fieldName].slice(0, -1));
                                } else if ((fieldName == 'rx_pkt' || fieldName == 'tx_pkt') && (2 & flag) > 0) { // pkt
                                    columns.push(db[x][fieldName].slice(0, -1));
                                }
                            }
                        }
                    }
                }
            }

            console.log(JSON.stringify(columns));
            /* update c3 chart */
            if (conn.port_data_ready && conn['port_sts']) {
                var same = _this.checkUnload(chart, columns);
                if (same) {
                    /* update c3 chart */
                    chart.loading = true;
                    chart.load({
                        x: 'ts',
                        columns: columns,
                        done: function() {
                            setTimeout(function() { chart.loading = false; }, c3_wrapper.prototype.destroy_delay);
                        }
                    });
                }
            }
        }, 1000);
    } else if (data_type == 'dpi') {
        setId = setInterval(function() {
            var db = conn.data['dpi'];
            var rank = chart.rt_rank;

            /* prepare columns */
            var columns = [];
            columns.push(conn['dpi_ts']);
            //for(var x in db) {
            //var field = x; // protoName_byte or protoName_pkt
            //var last_char = field.charAt(field.length-1);
            //var protoName;
            //var byteORpkt; // byte: 1, pkt: 2
            //if(last_char=='e') {
            //protoName = field.slice(0, -5);
            //byteORpkt = 1;
            //}
            //else if(last_char=='t') {
            //protoName = field.slice(0, -4);
            //byteORpkt = 2;
            //}
            //else {
            //throw "error dpi field: "+field;
            //}

            //if(conn.showFilter['dpi']==null || _this.inArray(protoName, conn.showFilter['dpi'])) { // check protocol showFilter
            //var flag = conn.showFilter['bp_flag'];
            //if((byteORpkt&flag)>0) { // check byte and pkt flag
            //columns.push(db[x]);
            //}
            //}
            //}

            var flag = conn.showFilter['bp_flag'];
            window.bp_stat = flag;
            // XXX: because of protocol tag, flag==3 => show only byte
            if ((1 & flag) > 0) { // byte
                addDPIcolumn.call(_this, conn, columns, 'byte', rank);
            } else if ((2 & flag) > 0) { // pkt
                addDPIcolumn.call(_this, conn, columns, 'pkt', rank);
            }

            // type => byte or pkt
            function addDPIcolumn(conn, columns, type, rankLimit) {
                if (type != 'byte' && type != 'pkt')
                    throw "unknown type in addDPIcolumn";

                // [{name: protoName, value: int}, ...]
                var cnt = 0;
                var arr = conn.dpi_rank[type];
                var db = conn.data['dpi'];
                for (var x in arr) {
                    var protoName = arr[x]['name'];
                    if (conn.showFilter['dpi'] == null || this.inArray(protoName, conn.showFilter['dpi'])) { // check protocol showFilter
                        columns.push(db[protoName + '_' + type]);
                        cnt++;
                        if (cnt == rankLimit)
                            return;
                    }
                }
            }

            console.log(JSON.stringify(columns));

            /* check whether same protocol rank list */
            var same = _this.checkUnload(chart, columns);
            if (same) {
                /* update c3 chart */
                console.log(JSON.stringify(columns));
                chart.loading = true;
                chart.load({
                    x: 'ts',
                    columns: columns,
                    done: function() {
                        setTimeout(function() { chart.loading = false; }, c3_wrapper.prototype.destroy_delay);
                    }
                });
            }

        }, 1000);
    } else
        throw "unknown type";

    conn.intervalId = setId;
    chart.unload_flag = true;
    chart.show_type = 'line';
    return true;
}

c3_wrapper.prototype.stopShow = function(chart) {
    if (!chart.hasOwnProperty("show_type")) {
        console.log("chart was not showed yet");
        return false;
    }

    // XXX: hard code... pie and gauge can have connection
    if (chart.show_type == "pie" || chart.show_type == 'gauge') {
        clearInterval(chart.intervalId);
        delete chart.intervalId;
        return true;
    } else { // line
        var conn = this.chart2conn(chart);
        if (conn) {
            if (conn.intervalId) {
                clearInterval(conn.intervalId);
                delete conn.intervalId;
                return true;
            }
        }
    }

}

c3_wrapper.prototype.setHistorySize = function(chart, size) {
    var conn = this.chart2conn(chart);
    if (conn) {
        conn.size = size;
    }
}

c3_wrapper.prototype.clearData = function(chart) {
    var conn = this.chart2conn(chart);
    if (conn) {
        conn['dpi_ts'] = ['ts'];
        conn['port_ts'] = ['ts'];
        conn['dpi_sts'] = null;
        conn['port_sts'] = null;
        conn['data'] = { 'dpi': {}, 'port': {} };
        conn['port_data_ready'] = false;
        conn['dpi_rank'] = { byte: [], pkt: [], avg_byte: {}, avg_pkt: {} };
        chart.unload_flag = true;
    }
}

c3_wrapper.prototype.chart2conn = function(chart) {
    if (chart == null)
        return null;

    for (var x in this.manager) {
        var conn = this.manager[x];
        if (conn.ref == chart) {
            return conn;
        }
    }
    return null;
}

/* similar to chart2conn, but remove before return */
c3_wrapper.prototype.removeConnByChart = function(chart) {
    if (chart == null)
        return null;

    for (var x in this.manager) {
        var conn = this.manager[x];
        if (conn.ref == chart) {
            this.manager.splice(x, 1); // remove
            return conn;
        }
    }
    return null;
}

/*********        PROTOCOL PIE CHART          *********/
/*
 * give dpid and show protocol traffic percentage of each child switches
 * XXX: For convenience, does not use connection conception...
 * Instead, record show_type and intervalId in chart
 * */
c3_wrapper.prototype.showProtoContributePie = function(chart, dpid, protoName, shareChart = null, interval = 2000) {
    if (chart.hasOwnProperty('intervalId')) {
        console.log("chart already showed");
        return false;
    }
    if (typeof protoName == 'undefined') {
        console.log("undefined protoName");
        return false;
    }
    if (shareChart == null) {
        console.log("null shareChart");
        return false;
    }

    var _this = this;
    var myfunc = function() {
        var dpi = _this.dpi_oper;
        var child_list;
        try {
            child_list = dpi.tree[dpid].child;
        } catch (err) {
            console.log(err.stack);
            return;
        }

        var shareConn = _this.chart2conn(shareChart);
        var bp_flag = shareConn.showFilter['bp_flag']; // bp depends on line chart
        var data = dpi.getDPIById(child_list);
        var columns = [
            ['ts', 0]
        ];
        for (var x in data) {
            var cdpid_str = x.toString();
            var dpi_list = data[x];
            var found = false;
            for (var i in dpi_list) {
                var entry = dpi_list[i];
                if (entry['protoName'] == protoName) {
                    found = true;
                    if (bp_flag == 1) {
                        columns.push([cdpid_str, entry['bytes']]);
                    } else if (bp_flag == 2) {
                        columns.push([cdpid_str, entry['packets']]);
                    }
                    break;
                }
            }
            if (!found) {
                columns.push([cdpid_str, 0]); // not found
            }
        }

        var host_list = dpi.sw_host_table[dpid];
        for (var x in host_list) {
            //console.log(JSON.stringify(host_list[x]));
            var host_name = host_list[x];
            var host_data = dpi.getDPIById(host_name);
            var found = false;
            for (var i in host_data) {
                var entry = host_data[i];
                if (entry['protoName'] == protoName) {
                    found = true;
                    if (bp_flag == 1) {
                        columns.push([host_name, entry['bytes']]);
                    } else if (bp_flag == 2) {
                        columns.push([host_name, entry['packets']]);
                    }
                    break;
                }
            }
            if (!found) {
                columns.push([host_name, 0]); // not found
            }
        }

        //console.log(JSON.stringify(columns));
        chart.transform('pie');
        var same = _this.checkUnload(chart, columns);
        if (same) {
            chart.loading = true;
            chart.load({
                columns: columns,
                done: function() {
                    setTimeout(function() { chart.loading = false; }, c3_wrapper.prototype.destroy_delay);
                }
            });
        }
    };
    chart.unload_flag = true;
    myfunc();
    var intervalId = setInterval(myfunc, interval);
    chart.show_type = "pie";
    chart.intervalId = intervalId;
    return true;
}

/*
 * If shareChart is not set, show this id's percentage of protocols.
 * If set, sync type, data, legend of line chart // including rank and showFilter
 * bp_flag: 1=> byte, 2=>pkt
 * */
c3_wrapper.prototype.showProtoPie = function(chart, id, bp_flag = 1, interval = 2000, shareChart = null) {
    if (chart.hasOwnProperty('intervalId')) {
        console.log("chart already showed");
        return false;
    }
    if (shareChart == null && bp_flag != 1 && bp_flag != 2) {
        console.log("unknown bp_flag in showProtoPie");
        return false;
    }

    var _this = this;
    var dpi = this.dpi_oper;
    var myfunc;
    if (shareChart == null) {
        myfunc = function() {
            var data = dpi.getDPIById(id);
            var columns = [
                ['ts', 0]
            ];
            for (var x in data) {
                var entry = data[x];
                if (bp_flag == 1) {
                    columns.push([entry['protoName'], entry['bytes']]);
                } else if (bp_flag == 2) {
                    columns.push([entry['protoName'], entry['packets']]);
                }
            }

            //console.log(JSON.stringify(columns));
            chart.transform('pie');
            var same = _this.checkUnload(chart, columns);
            if (same) {
                chart.loading = true;
                chart.load({
                    columns: columns,
                    done: function() {
                        setTimeout(function() { chart.loading = false; }, c3_wrapper.prototype.destroy_delay);
                    }
                });
            }
        };
    } else {
        var shareConn = this.chart2conn(shareChart);
        myfunc = function() {
            var columns = [];
            var rt_rank = shareChart.internal.legend[0][0].childNodes.length;
            columns.push(shareConn['dpi_ts']);
            var bp_flag = shareConn.showFilter['bp_flag'];
            if (bp_flag == 1) { // byte
                addDPIcolumn.call(_this, shareConn, columns, 'byte', rt_rank);
            } else if (bp_flag == 2) { // pkt
                addDPIcolumn.call(_this, shareConn, columns, 'pkt', rt_rank);
            }

            chart.transform('pie');
            var same = _this.checkUnload(chart, columns);
            if (same) {
                /* update c3 chart */
                chart.loading = true;
                chart.load({
                    x: 'ts',
                    columns: columns,
                    done: function() {
                        setTimeout(function() { chart.loading = false; }, c3_wrapper.prototype.destroy_delay);
                    }
                });
            }

            // type => byte or pkt
            function addDPIcolumn(shareConn, columns, type, rankLimit) {
                if (type != 'byte' && type != 'pkt')
                    throw "unknown type in addDPIcolumn";

                // [{name: protoName, value: int}, ...]
                var cnt = 0;
                var arr = shareConn.dpi_rank[type];
                var db = shareConn.data['dpi'];
                for (var x in arr) {
                    var protoName = arr[x]['name'];
                    if (shareConn.showFilter['dpi'] == null || _this.inArray(protoName, shareConn.showFilter['dpi'])) { // check protocol showFilter
                        columns.push(db[protoName + '_' + type]);
                        cnt++;
                        if (cnt == rankLimit)
                            return;
                    }
                }
            }
        }
    }
    chart.unload_flag = true;
    myfunc();
    var intervalId = setInterval(myfunc, interval);
    chart.show_type = "pie";
    chart.intervalId = intervalId;
    return true;
}

/* 
 * show link gauge on two chart
 * use src port data to prepare columns
 * ids: [src_id, dst_id] // src_id must be dpid
 * port_no: src_id's port_no => dst_id
 * */
c3_wrapper.prototype.showLinkGauge = function(chart_st, chart_ts, ids, port_no = null, shareChart = null, interval = 1000) {
    if (shareChart == null || port_no == null) {
        console.log("shareChart or port_no is null");
        return false;
    }
    if (chart_st.hasOwnProperty('intervalId')) {
        console.log("chart_st already showed");
        return false;
    }
    if (chart_ts.hasOwnProperty('intervalId')) {
        console.log("chart_ts already showed");
        return false;
    }

    // byte and pkt flag define in line chart 
    var shareConn = this.chart2conn(shareChart);
    if (shareConn == null) {
        console.log("null conn");
        return false;
    }

    var _this = this;
    var dpi = this.dpi_oper;

    var st_func;
    st_func = function() {
        if (!shareConn.port_data_ready || !shareConn['port_sts'])
            return;

        var columns = [];
        var db = shareConn.data['port'];
        var data = db[port_no];

        var len = data['tx_byte'].length;
        var bp_flag = shareConn.showFilter['bp_flag'];
        if (bp_flag == 1) { // byte
            columns.push(['data', Math.floor(data['tx_byte'][len - 2] / 1024)]);
        } else { // pkt
            columns.push(['data', Math.floor(data['tx_pkt'][len - 2])]);
        }

        /* update c3 chart */
        chart_st.loading = true;
        chart_st.load({
            columns: columns,
            done: function() {
                setTimeout(function() { chart_st.loading = false; }, c3_wrapper.prototype.destroy_delay);
            }
        });
    };
    var st_intervalId = setInterval(st_func, interval);
    chart_st.show_type = "gauge";
    chart_st.unload_flag = true;
    chart_st.intervalId = st_intervalId;

    var ts_func;
    ts_func = function() {
        if (!shareConn.port_data_ready || !shareConn['port_sts'])
            return;

        var columns = [];
        var db = shareConn.data['port'];
        var data = db[port_no];

        var len = data['rx_byte'].length;
        var bp_flag = shareConn.showFilter['bp_flag'];
        if (bp_flag == 1) { // byte
            columns.push(['data', Math.floor(data['rx_byte'][len - 2] / 1024)]);
        } else { // pkt
            columns.push(['data', Math.floor(data['rx_pkt'][len - 2])]);
        }

        /* update c3 chart */
        chart_ts.loading = true;
        chart_ts.load({
            columns: columns,
            done: function() {
                setTimeout(function() { chart_ts.loading = false; }, c3_wrapper.prototype.destroy_delay);
            }
        });
    };
    var ts_intervalId = setInterval(ts_func, interval);
    chart_ts.show_type = "gauge";
    chart_ts.unload_flag = true;
    chart_ts.intervalId = ts_intervalId;

    return true;
}

c3_wrapper.prototype.showSwGauge = function(chart_rx, chart_tx, shareChart = null, interval = 1000) {
    if (shareChart == null) {
        console.log("shareChart is null");
        return false;
    }
    if (chart_rx.hasOwnProperty('intervalId')) {
        console.log("chart_rx already showed");
        return false;
    }
    if (chart_tx.hasOwnProperty('intervalId')) {
        console.log("chart_tx already showed");
        return false;
    }

    // byte and pkt flag define in line chart 
    var shareConn = this.chart2conn(shareChart);
    if (shareConn == null) {
        console.log("null conn");
        return false;
    }

    var _this = this;
    var dpi = this.dpi_oper;

    var tx_func;
    tx_func = function() {
        if (!shareConn.port_data_ready || !shareConn['port_sts'])
            return;

        var columns = [];
        var db = shareConn.data['port'];

        var sum = 0;
        for (var port_no in db) {
            // XXX: suppose no tot_xxx fields
            var data = db[port_no];
            var len = data['tx_byte'].length;
            var bp_flag = shareConn.showFilter['bp_flag'];
            if (bp_flag == 1) { // byte
                sum += data['tx_byte'][len - 2] / 1024;
            } else { // pkt
                sum += data['tx_pkt'][len - 2];
            }
        }
        columns.push(['data', Math.floor(sum)]);

        /* update c3 chart */
        chart_tx.loading = true;
        chart_tx.load({
            columns: columns,
            done: function() {
                setTimeout(function() { chart_tx.loading = false; }, c3_wrapper.prototype.destroy_delay);
            }
        });
    };
    var tx_intervalId = setInterval(tx_func, interval);
    chart_tx.show_type = "gauge";
    chart_tx.unload_flag = true;
    chart_tx.intervalId = tx_intervalId;

    var rx_func;
    rx_func = function() {
        if (!shareConn.port_data_ready || !shareConn['port_sts'])
            return;

        var columns = [];
        var db = shareConn.data['port'];

        var sum = 0;
        for (var port_no in db) {
            // XXX: suppose no tot_xxx fields
            var data = db[port_no];
            var len = data['rx_byte'].length;
            var bp_flag = shareConn.showFilter['bp_flag'];
            if (bp_flag == 1) { // byte
                sum += data['rx_byte'][len - 2] / 1024;
            } else { // pkt
                sum += data['rx_pkt'][len - 2];
            }
        }
        columns.push(['data', Math.floor(sum)]);

        /* update c3 chart */
        chart_rx.loading = true;
        chart_rx.load({
            columns: columns,
            done: function() {
                setTimeout(function() { chart_rx.loading = false; }, c3_wrapper.prototype.destroy_delay);
            }
        });
    };
    var rx_intervalId = setInterval(rx_func, interval);
    chart_rx.show_type = "gauge";
    chart_rx.unload_flag = true;
    chart_rx.intervalId = rx_intervalId;

    return true;
}

c3_wrapper.prototype.changeRT_RANK = function(chart, rt_rank) {
    if (chart.hasOwnProperty('rt_rank')) {
        chart.rt_rank = rt_rank;
        chart.unload_flag = true;
        return true;
    } else {
        console.log("line chart must be started first");
        return false;
    }
}

c3_wrapper.prototype.changeBP_FLAG = function(chart, bp_flag) {
    var conn = this.chart2conn(chart);
    if (bp_flag > 3 || bp_flag <= 0) {
        console.log("bp_flag error");
        return false;
    }
    conn['showFilter']['bp_flag'] = bp_flag; // show both port and byte
    chart.unload_flag = true;
    return true;
}

/*
 * dimension: [width, height]
 * type: pie, line, gauge
 * bind: bind element
 * */
c3_wrapper.prototype.genSimpleChart = function(dimension = null, type = null, bind = null) {
    if (!dimension || !type || !bind) {
        throw "param error";
        return;
    }
    console.log(type);
    if (type != 'pie' && type != 'line' && type != 'gauge') {
        throw "type error";
        return;
    }

    if (type == 'pie') {
        return c3.generate({
            bindto: bind,
            size: {
                height: dimension[0],
                width: dimension[1]
            },
            data: {
                x: 'ts',
                type: 'pie',
                columns: []
            },
        });
    } else if (type == 'gauge') {
        return c3.generate({
            bindto: bind,
            size: {
                height: dimension[0],
                width: dimension[1]
            },
            data: {
                type: 'gauge',
                columns: []
            },
            gauge: {
                label: {
                    format: function(value, ratio) {
                        return value;
                    },
                },
                min: 0,
                max: 1000,
                units: 'K bits'
            }
        });
    } else if (type == 'line') {
        return c3.generate({
            bindto: bind,
            size: {
                height: dimension[0],
                width: dimension[1]
            },
            data: {
                x: 'ts',
                columns: []
            },
        });
    }
}

/* dpi demo */
// connectData = function(chart, id, connFilter={dpi: null, port: null}, showFilter={dpi: null, port: null, bp_flag: null, port_no: null}, size=10, failTime=0)

function demo(node) {
    var id = node.id;
    c3w.connectData(live_dpi_chart, id, null, { port_no: null, bp_flag: 1 }); // show all protocols info. of dpid 1
    c3w.startShowLine(live_dpi_chart, 'dpi', 3);
    c3w.showProtoPie(pie_chart, 1, 2, 2000, live_dpi_chart); // chart, id, bp_flag, shareChart, rt_rank
    //c3w.showProtoContributePie(contribute_chart, 1, 'HTTP', 'pkt');
}

/******   LINK DEMO   ********/

/* link demo */
function demo2(link) {

    /* prepare variable */
    // variable => port_no, src, dst
    var ids = [link.source.id, link.target.id];
    var port_no;
    var sw_or_host = [];
    sw_or_host.push(dpi.checkIPv4(ids[0]));
    sw_or_host.push(dpi.checkIPv4(ids[1]));

    /* link check */
    if (sw_or_host[0] && sw_or_host[1]) { // both host
        console.log("two hosts?");
        return false;
    } else if (sw_or_host[0]) { // former host
        var tmp = ids[0];
        ids[0] = ids[1];
        ids[1] = tmp;
        port_no = link.properties.sw_in_port;
    } else if (sw_or_host[1]) { // lattar host
        port_no = link.properties.sw_in_port;
    } else { // no host
        port_no = link.properties.src_port;
    }

    /* show line chart */
    c3w.connectData(live_dpi_chart, ids[0], { dpi: [], port: null }, { bp_flag: 1, port_no: port_no }); // bp_flag==2 -> show pkt info
    c3w.startShowLine(live_dpi_chart, 'port', 0); // chart, type, bp_flag==0 -> show both rx and tx

    /* gauge chart */
    c3w.showLinkGauge(rx_gauge, tx_gauge, ids, port_no, live_dpi_chart);

    /* change title */
    $("#tx_title").text(ids[0].toString() + "  =>  " + ids[1].toString());
    $("#rx_title").text(ids[1].toString() + "  =>  " + ids[0].toString());

    console.log(port_no);
    return ids;
}

function reconstructPort() {
    window.dp_stat = 1; // default dpi mode
    c3w.destroy(window.live_dpi_chart);
    c3w.destroy(window.rx_gauge);
    c3w.destroy(window.tx_gauge);
    //setTimeout(initChart, 300); // need some delay or chart can't be visualized...
}

function reconstructDPI() {
    window.dp_stat = 1; // default dpi mode
    c3w.destroy(window.live_dpi_chart);
    c3w.destroy(window.pie_chart);
    c3w.destroy(window.contribute_chart);
}

/*
 * XXX: init without delay will make the chart broken
 * */
function initChart() {
    window.live_dpi_chart = c3w.genSimpleChart([300, 520], 'line', "#line_chart");
    window.rx_gauge = c3w.genSimpleChart([225, 275], 'gauge', "#rx_gauge");
    window.tx_gauge = c3w.genSimpleChart([225, 275], 'gauge', "#tx_gauge");
}

/******   NODE DEMO   ********/
function demo3() {
    c3w.connectData(live_dpi_chart, 1, null, { port_no: null, bp_flag: 1 }); // show all protocols info. of dpid 1
    c3w.startShowLine(live_dpi_chart, 'dpi', 3);
    c3w.showProtoPie(pie_chart, 1, 2, 2000, live_dpi_chart); // chart, id, bp_flag, shareChart, rt_rank
    //c3w.showProtoContributePie(contribute_chart, 1, 'HTTP', 'pkt');
}

function demo4(node) {
    var id = node.id;
    c3w.connectData(live_dpi_chart, id, null, { port_no: null, bp_flag: 1 }); // show all protocols info. of dpid 1
    //c3w.stopShow(live_dpi_chart);
    c3w.startShowLine(live_dpi_chart, 'port', 1);
    c3w.showSwGauge(rx_gauge, tx_gauge, live_dpi_chart);
}

window.bp_stat = 1;
window.rt_stat = 1; // only node need
window.dp_stat = 1; // 1: dpi, 2: port
window.cur_id = null;

function dp_changePage() {
    if (window.dp_stat == 1) {
        $("#rx_gauge").hide();
        $("#tx_gauge").hide();
        $("#proto_pie_chart").show();
        $("#contribute_pie_chart").show();
    } else {
        $("#rx_gauge").show();
        $("#tx_gauge").show();
        $("#proto_pie_chart").hide();
        $("#contribute_pie_chart").hide();
    }
}
